package no.kommune.oslo.methodology

import no.kommune.oslo.methodology.VulnerabilityScore.ScoreType.EXISTING_SCORE
import no.kommune.oslo.model.RiskTreatment
import no.kommune.oslo.model.SeverityLevels
import no.kommune.oslo.model.SeverityLevels.INSIGNIFICANT
import no.kommune.oslo.model.Threat
import no.kommune.oslo.model.Vulnerability
import org.apache.logging.log4j.LogManager

abstract class SimpleVulnerabilityScoreCalculation : VulnerabilityScoreCalculation {
    override val vulnerabilityScoreValue: SeverityLevels
        get() = TODO("Not yet implemented")
    private val logger = LogManager.getLogger(javaClass)


    override fun calculateExistingVulnerability(vulnerability: Vulnerability,
                                                exploitingThreats: List<Threat>,
                                                riskTreatments: List<RiskTreatment>,
                                                riskCalculationStrategy: RiskCalculationStrategy,
                                                weightFactorPercentage: Int): VulnerabilityScore {
        if (exploitingThreats.isEmpty()) {
            logger.debug("No exploiting threats, setting Severity Level to $INSIGNIFICANT")
            return VulnerabilityScore(INSIGNIFICANT, EXISTING_SCORE)
        }

        // Find max threat level
        val threatPresenceScore = riskCalculationStrategy.calculateThreatPresence(exploitingThreats, weightFactorPercentage)
        // Average with vulnerability score
        val existingVulnerability = (vulnerability.vulnerabilityPotential.severityLevelValue * threatPresenceScore) / 2
        logger.debug("threatPresenceScore: $threatPresenceScore, " +
                "vulnerabilityPotential: $vulnerability.vulnerabilityPotential.severityLevelValue, " +
                "calculated existing vulnerability $existingVulnerability")

        //TODO("Add algorithm to decrease score based on relevant risk treatments")

        //TODO("Refactor above algorithm to private method with parameter controlling existing/future vulnerability calculation")

        return VulnerabilityScore(SeverityLevels.getByValue(existingVulnerability), EXISTING_SCORE)
    }
}